import chapter.four.ReleaseVersionListener
import chapter.four.ReleaseVersionTask
import chapter.four.Version

/**
 * <h4>4.1</h4>
 * Summary of {@link Project} and {@link Task} and Properties.
 * <p>
 * Interesting was the use of the gradle.properties file which is automatically read into build script. A
 * gradle.properties file can also be defined in the <USER_HOME>/.gradle directory which will be automatically read
 * into <strong>every</strong> build script.
 * <h4>4.2</h4>
 * Overview of task creation
 * <ul>
 *     <li>Using Groovy classes to encapsulate various project properties
 *     <li>Task rule creation
 *     <li>Extending the {@link DefaultTask} to create enhanced tasks/task types to further increase encapsulation
 *     <li>Moving tasks types
 *     <li>Using Gradle's built in task types {@link Copy} and {@link Zip}
 * </ul>
 * <h4>4.3.</h4>
 * Overview of listening to Gradle's build life cycle specifically focusing task graph creation attached a listener via:
 * <ul>
 *     <li>A {@link Closure} using {@link TaskExecutionGraph#whenReady(groovy.lang.Closure)}
 *     <li>A {@link TaskExecutionGraphListener} using {@link TaskExecutionGraph#addTaskExecutionGraphListener(org.gradle.api.execution.TaskExecutionGraphListener)}
 * </ul>
 */
private void Summary() {}

version = 'Playground project instance'

task printInstances {
    description "Attempt to find out what the class instance Gradle DSL entities actually map to"
} << {
    //Thought this would be a instance of Gradle project however it comes out be something like build_(some hash?)
    println this.class
}

//Defines additional properties on the project instance (which is pretty much the 'this')
ext {
    hiThere = 'Hi there'
    myVersion = 'Playground ext{}'
    version = 'Playground ext{}'
}

task displayExtProperties {
    description "Displays user defined properties"
} << {
    println "hiThere: $project.hiThere"
    println "myVersion: $project.myVersion"
    println "version: $project.version"
}

def version = "Playground"

task printVersionTest {
    group "Questionable"
    description "Print version"
} << {
    println version
    println project.version
}

task loggerTest {
    group "versioning"
} << {
    logger.quiet version
}


task first << {
    def str = "";
    for (int i = 0; i < 10000; i++) {
        str += " " + i;
    }
    println "First $str"
}

task second << {
    println "Second"
}

/*
 * Dependent task have to be defined before hand
 * Unless I'm doing it incorrectly getting Gradle to build in parallel doesn't seem to work in this test
 * Rather 'first' always executes before 'second', it seems that be defaults to running task in alphabetical order
 */
task parallelTest {
    group "Questionable"
    dependsOn first, second
}

task finalizationTest {
    finalizedBy second
}

//Read version.properties file
Version loadVersionFile() {
    logger.quiet 'Reading the version file.'
    if (!versionFile.exists()) {
        throw new GradleException("Required version file does not exist: $versionFile.canonicalPath")
    }
    Properties versionProps = new Properties()
    versionFile.withInputStream { stream -> versionProps.load(stream) }
    new Version(Boolean.parseBoolean(versionProps.playground), Integer.parseInt(versionProps.major), Integer.parseInt(versionProps.minor), Boolean.parseBoolean(versionProps.release))
}

ext {
    versionFile = file('version.properties');
    versionClass = loadVersionFile();
}

task printVersionClass {
    group = 'versioning'
} << {
    println versionClass
}

//There's a lot going on in task inputs and outputs
task makeReleaseVersion {
    group = 'versioning'
    description 'Standard task to create release version, checking if a version.properties.release has changed and the version.properties file has changed'
    //Check if the release property in version.properties is the same as in the previous run
    inputs.property('release', versionClass.release)
    //Check if the versionFile is the same as in the previous run
    outputs.file versionFile
} << {
    versionClass.release = true
    ant.propertyfile(file: versionFile) {
        entry(key: 'release', type: 'string', operation: '=', value: 'true')
    }
}

task postReleaseTask {
    group = 'versioning'
    dependsOn makeReleaseVersion
} << {
    println versionClass.release
}

task makeReleaseVersionCustomTask(type: ReleaseVersionTask) {
    release = versionClass.release
    destFile = versionFile
} << {
    println versionClass
}

task zipTest(type: Zip) {
    baseName = "src"
    destinationDir = buildDir
    from('src') {
        into 'src'
    }

    from(rootDir) {
        include versionFile.name
    }
}

//Copy zip file into build directory
task backupZipTest(type: Copy) {
    //Dependent task zipTest is automatically ran
    //Where does the zipTest/Zip task define it's outputs
    from zipTest.outputs.files
    //Default buildDir is /build
    into "$buildDir/backup"
}


tasks.addRule("Pattern: increment<Classifier>Version - Increments the project version classifier.") {
    String taskName ->
        if (taskName.startsWith('increment') && taskName.endsWith('Version')) {
            String oldVersion = versionClass.toString();
            task(taskName) << {
                String classifier = (taskName - 'increment' - 'Version').toLowerCase()
                switch (classifier) {
                    case 'major':
                        ++versionClass.major
                        break
                    case 'minor':
                        ++versionClass.minor
                        break
                    default:
                        throw new GradleException("Invalid version type $classifier. Allowed types: ['Major', 'Minor'] ")
                }
                String newVersion = versionClass.toString();
                ant.propertyfile(file: versionFile) {
                    //using any's synatx to increment major/minor version
                    entry(key: classifier, type: 'int', operation: '+', value: 1);
                }
                logger.info "Incrementing $classifier project version: $oldVersion -> $newVersion"
            }
        }
}

task release(dependsOn: [makeReleaseVersionCustomTask, backupZipTest]) {
    description = 'Create release updating version.properties and creating zip of src and backup'
    group = 'versioning'
}

task releaseUsingExecutionGraphClosure(dependsOn: backupZipTest) {
    description = 'Use Closure to listen to task execution graph creation'
    group = 'versioning'
}

task descriptionTest(description: "Set in constructor") {
    description 'Setter using space'
    description = 'Setter using ='
    setDescription('Setter using classic method')
}

gradle.taskGraph.whenReady {
    TaskExecutionGraph taskGraph ->
        if (taskGraph.hasTask(releaseUsingExecutionGraphClosure)) {
            //if not a release version
            if (!versionClass.release) {
                versionClass.release = true;
                ant.propertyfile(file: versionFile) {
                    entry(key: 'release', type: 'string', operation: '=', value: 'true')
                }
            }
        }
}

task releaseUsingExecutionGraphListener(dependsOn: backupZipTest) {
    description = 'Use Listener to listen to task execution graph creation'
    group = 'versioning'
}

gradle.taskGraph.addTaskExecutionGraphListener(new ReleaseVersionListener())